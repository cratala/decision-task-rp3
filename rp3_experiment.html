<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Decision Task</title>
    <script src="https://unpkg.com/jspsych@7.3.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.2"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.2"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-multi-choice@1.1.2"></script>
    <link href="https://unpkg.com/jspsych@7.3.3/css/jspsych.css" rel="stylesheet" type="text/css" />
    <style>
        body {
            background-color: white;
            color: black;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        .advice-box {
            position: absolute;
            right: 50px;
            top: 150px;
            width: 420px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
            padding: 25px;
            border: 3px solid black;
            background-color: #fffef9;
        }
        
        .advice-box.ai {
            background-color: #fffef9;
            border-color: black;
        }
        
        .advice-box.human {
            background-color: #fffef9;
            border-color: black;
        }
        
        .advice-icon {
            display: none; /* Icons removed */
        }
        
        .advice-header {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 15px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: black;
        }
        
        .advice-header.ai {
            color: black;
        }
        
        .advice-header.human {
            color: black;
        }
        
        .advice-text {
            font-size: 20px;
            color: black;
            line-height: 1.7;
            font-weight: 500;
            margin-top: 15px;
        }
        
        .advice-recommendation {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 22px;
            margin-top: 15px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
        }
        
        .advice-recommendation.in {
            background: linear-gradient(135deg, #e8f4ff 0%, #d4edff 100%);
            color: #1a365d;
        }
        
        .advice-recommendation.out {
            background: linear-gradient(135deg, #fff0e8 0%, #ffe4d4 100%);
            color: #5c2e00;
        }
        
        .history-container {
            position: absolute;
            left: 50px;
            top: 150px;
            width: 380px;
        }
        
        .history-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .history-boxes {
            display: flex;
            justify-content: space-around;
            gap: 15px;
        }
        
        .history-box {
            width: 85px;
            height: 100px;
            border: 3px solid black;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .history-box.in {
            background-color: #e8f4ff;
        }
        
        .history-box.out {
            background-color: #fff0e8;
        }
        
        .round-label {
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .decision-label {
            font-size: 20px;
        }
        
        .decision-area {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        
        .decision-prompt {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 30px;
        }
        
        .choice-buttons {
            display: flex;
            gap: 50px;
            justify-content: center;
        }
        
        .choice-button {
            width: 200px;
            height: 80px;
            font-size: 28px;
            font-weight: bold;
            border: 4px solid black;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .choice-button.in {
            background-color: #e8f4ff;
        }
        
        .choice-button.out {
            background-color: #fff0e8;
        }
        
        .choice-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .timer-bar-container {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
        }
        
        .timer-bar-bg {
            width: 100%;
            height: 50px;
            background-color: lightgray;
            border: 4px solid black;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .timer-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%);
            transition: width 0.1s linear;
        }
        
        .timer-warning {
            color: #dc2626;
            font-size: 42px;
            font-weight: bold;
            text-align: center;
            margin-top: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: pulse 0.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .instructions {
            max-width: 800px;
            margin: 50px auto;
            padding: 30px;
            line-height: 1.8;
            font-size: 18px;
        }
        
        .instructions h1 {
            color: #2d3748;
            margin-bottom: 30px;
        }
        
        .instructions h2 {
            color: #4a5568;
            margin-top: 30px;
            margin-bottom: 20px;
        }
        
        .instructions ul {
            text-align: left;
            max-width: 650px;
            margin: 20px auto;
        }
        
        .break-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-size: 24px;
            text-align: center;
        }
        
        /* Comprehension check button styling */
        .jspsych-btn {
            transition: all 0.2s ease;
        }
        
        .jspsych-btn:hover {
            background-color: #e8f4ff !important;
            transform: scale(1.05);
        }
        
        .jspsych-btn:active {
            background-color: #a8d8ff !important;
            transform: scale(0.98);
        }
        
        .break-title {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 30px;
            color: #4A5F7A;
        }
        
        .break-countdown {
            font-size: 48px;
            font-weight: bold;
            color: #7B9BB5;
            margin: 30px 0;
        }
        
        .stress-warning {
            font-size: 28px;
            color: #dc2626;
            font-weight: bold;
            margin: 20px 0;
            padding: 20px;
            background: #fee;
            border-radius: 10px;
            border: 3px solid #dc2626;
        }
        
        .fixation-cross {
            font-size: 80px;
            font-weight: bold;
            color: black;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .fade-in {
            animation: fadeIn 0.5s forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .comprehension-feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .comprehension-feedback.correct {
            background-color: #d4edda;
            color: #155724;
            border: 2px solid #28a745;
        }
        
        .comprehension-feedback.incorrect {
            background-color: #f8d7da;
            color: #721c24;
            border: 2px solid #dc3545;
        }
    </style>
</head>
<body></body>
<script>

// ============================================================================
// CONFIGURATION - EASY TO MODIFY
// ============================================================================

const CONFIG = {
    // ‚öôÔ∏è TIMING SETTINGS - Change these values easily
    DECISION_TIME_WITH_PRESSURE: 8000,  // 8 seconds for Block 2 (time pressure)
    BREAK_DURATION: 10000,              // 10 seconds break between blocks
    ITI_DURATION: 500,                  // 500ms between trials
    FIXATION_DURATION: 500,            // 0.5 second fixation cross
    
    // üìä TRIAL SETTINGS - Modified Option B (3 per condition)
    TRIALS_PER_BLOCK: 18,               // 18 trials per block (36 total)
    TRIALS_PER_ADVICE_TYPE: 6,          // 6 trials each: none, AI, human
    
    // üí∞ PAYOFF SETTINGS
    ENDOWMENT: 10,                      // Starting amount each round
    SHARE_AMOUNT: 20                    // Amount if both cooperate
};

// üé≤ RANDOMLY SELECT TASK TYPE (Social vs Non-social)
const RISK_DOMAIN = Math.random() < 0.5 ? 'Social' : 'Non-social';

console.log('Task type selected:', RISK_DOMAIN);

// ============================================================================
// PARTICIPANT CODE GENERATION
// ============================================================================

function generateParticipantCode() {
    const firstLetters = ['A', 'B', 'C', 'D', 'E', 'J', 'K', 'L', 'M', 'N', 'R', 'S', 'T', 'W'];
    const secondLetters = ['A', 'B', 'C', 'D', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'R', 'S', 'T', 'W', 'Y'];
    
    const first = firstLetters[Math.floor(Math.random() * firstLetters.length)];
    const second = secondLetters[Math.floor(Math.random() * secondLetters.length)];
    const number = Math.floor(Math.random() * 90) + 10;
    
    return `${first}${second}${number}`;
}

function generatePartnerCodes(numPartners) {
    const codes = new Set();
    while (codes.size < numPartners) {
        codes.add(generateParticipantCode());
    }
    return Array.from(codes);
}

const PARTICIPANT_CODE = generateParticipantCode();
const PARTNER_CODES_BLOCK1 = generatePartnerCodes(CONFIG.TRIALS_PER_BLOCK);
const PARTNER_CODES_BLOCK2 = generatePartnerCodes(CONFIG.TRIALS_PER_BLOCK);

// ============================================================================
// FIXATION CROSS
// ============================================================================

function createFixation() {
    return {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '<div class="fixation-cross">+</div>',
        choices: "NO_KEYS",
        trial_duration: CONFIG.FIXATION_DURATION
    };
}

// ============================================================================
// TRIAL GENERATION WITH BLOCKED ADVICE ORDER
// ============================================================================

function generateAdvice(history, adviceType, shouldBeGoodAdvice = null) {
    const cooperationRate = history.reduce((a, b) => a + b, 0) / history.length;
    // If shouldBeGoodAdvice not specified, randomize (for backwards compatibility)
    const isGoodAdvice = shouldBeGoodAdvice !== null ? shouldBeGoodAdvice : (Math.random() < 0.5);
    
    let adviceText = '';
    let recommendation = '';
    let quality = 'NA';
    let advisorId = '';
    let advisorColor = '';
    
    if (adviceType !== 'none') {
        if (adviceType === 'ai') {
            const aiNumber = Math.floor(Math.random() * 90) + 10;
            advisorId = `AI agent AI${aiNumber}`;
            advisorColor = 'ai';
        } else {
            const letters = ['A', 'B', 'C', 'D', 'E', 'J', 'K', 'L', 'M', 'N', 'R', 'S', 'T', 'W'];
            const l1 = letters[Math.floor(Math.random() * letters.length)];
            const l2 = letters[Math.floor(Math.random() * letters.length)];
            const num = Math.floor(Math.random() * 90) + 10;
            advisorId = `Participant ${l1}${l2}${num}`;
            advisorColor = 'human';
        }
        
        adviceText = "advises you to choose";
        
        // Determine optimal choice
        const optimalChoice = cooperationRate >= 0.67 ? "IN" : "OUT";
        
        if (isGoodAdvice) {
            recommendation = optimalChoice;
            quality = 'good';
        } else {
            recommendation = optimalChoice === "IN" ? "OUT" : "IN";
            quality = 'bad';
        }
    }
    
    return { adviceText, advisorId, advisorColor, recommendation, quality };
}

// ============================================================================
// FIXED HISTORY SET FOR CLEAN EXPERIMENTAL DESIGN
// ============================================================================

// 8 standardized histories covering the full cooperation spectrum
const FIXED_HISTORIES = [
    { pattern: [0, 0, 0], coopRate: 0.00, optimalChoice: 'OUT', label: 'All OUT' },
    { pattern: [1, 0, 0], coopRate: 0.33, optimalChoice: 'OUT', label: 'Low coop (1/3)' },
    { pattern: [0, 1, 0], coopRate: 0.33, optimalChoice: 'OUT', label: 'Low coop (1/3)' },
    { pattern: [0, 0, 1], coopRate: 0.33, optimalChoice: 'OUT', label: 'Low coop (1/3)' },
    { pattern: [1, 1, 0], coopRate: 0.67, optimalChoice: 'IN', label: 'High coop (2/3)' },
    { pattern: [1, 0, 1], coopRate: 0.67, optimalChoice: 'IN', label: 'High coop (2/3)' },
    { pattern: [0, 1, 1], coopRate: 0.67, optimalChoice: 'IN', label: 'High coop (2/3)' },
    { pattern: [1, 1, 1], coopRate: 1.00, optimalChoice: 'IN', label: 'All IN' }
];

function generateTrialSequence(blockNum, partnerCodes) {
    const trials = [];
    
    // üé≤ RANDOMIZE ORDER OF HUMAN AND AI ADVICE BLOCKS (counterbalancing)
    const adviceOrder = Math.random() < 0.5 ? ['human', 'ai'] : ['ai', 'human'];
    
    // ============================================================================
    // FIXED DESIGN STRUCTURE: 18 trials per block
    // - Trials 1-6: NO ADVICE (each sees 6 different histories)
    // - Trials 7-12: FIRST ADVICE TYPE (3 good + 3 bad, matched to histories)
    // - Trials 13-18: SECOND ADVICE TYPE (3 good + 3 bad, matched to histories)
    // ============================================================================
    
    // Create advice conditions array
    const adviceConditions = [
        ...Array(6).fill('none'),
        ...Array(6).fill(adviceOrder[0]),
        ...Array(6).fill(adviceOrder[1])
    ];
    
    // ============================================================================
    // HISTORY ASSIGNMENT STRATEGY
    // ============================================================================
    // Goal: Each participant sees all 8 histories at least once, with 10 repeats
    // We need 18 histories total (6 no-advice + 12 with-advice)
    
    // Shuffle the 8 fixed histories
    const shuffledHistories = [...FIXED_HISTORIES].sort(() => Math.random() - 0.5);
    
    // For the remaining 10 slots, sample from all 8 histories
    const additionalHistories = [];
    for (let i = 0; i < 10; i++) {
        additionalHistories.push(FIXED_HISTORIES[Math.floor(Math.random() * FIXED_HISTORIES.length)]);
    }
    
    // Combine: first 8 are unique, next 10 are samples
    const allHistories = [...shuffledHistories, ...additionalHistories];
    
    // Shuffle the combined array so histories appear in random order
    const finalHistories = [...allHistories].sort(() => Math.random() - 0.5);
    
    // ============================================================================
    // ADVICE QUALITY ASSIGNMENT (FIXED STRUCTURE)
    // ============================================================================
    // For advice trials (indices 6-17): assign 50% good, 50% bad
    // Good advice = recommends the optimal choice based on cooperation rate
    // Bad advice = recommends the opposite of optimal
    
    // Indices 6-11: First advice type (3 good, 3 bad)
    const firstAdviceIndices = [6, 7, 8, 9, 10, 11];
    const shuffledFirst = [...firstAdviceIndices].sort(() => Math.random() - 0.5);
    const firstGoodIndices = new Set(shuffledFirst.slice(0, 3));
    
    // Indices 12-17: Second advice type (3 good, 3 bad)
    const secondAdviceIndices = [12, 13, 14, 15, 16, 17];
    const shuffledSecond = [...secondAdviceIndices].sort(() => Math.random() - 0.5);
    const secondGoodIndices = new Set(shuffledSecond.slice(0, 3));
    
    const goodAdviceIndices = new Set([...firstGoodIndices, ...secondGoodIndices]);
    
    // ============================================================================
    // CREATE TRIALS
    // ============================================================================
    for (let i = 0; i < CONFIG.TRIALS_PER_BLOCK; i++) {
        const historyObj = finalHistories[i];
        const history = historyObj.pattern;
        const cooperationRate = historyObj.coopRate;
        
        // Partner cooperation: probabilistic based on history
        const willCooperate = Math.random() < cooperationRate;
        
        const adviceType = adviceConditions[i];
        
        // Determine if this trial should have good advice
        const shouldBeGoodAdvice = adviceType !== 'none' ? goodAdviceIndices.has(i) : null;
        
        const advice = generateAdvice(history, adviceType, shouldBeGoodAdvice);
        
        trials.push({
            block: blockNum,
            trialNum: i + 1,
            partnerCode: partnerCodes[i],
            history: history,
            cooperationRate: cooperationRate,
            optimalChoice: historyObj.optimalChoice,
            historyLabel: historyObj.label,
            willCooperate: willCooperate,
            adviceCondition: adviceType,
            ...advice
        });
    }
    
    return trials;
}

// ============================================================================
// TRIAL HTML CREATION
// ============================================================================

function createTrialHTML(trialData, showTimer) {
    const partnerLabel = RISK_DOMAIN === 'Social' ? 'PARTICIPANT' : 'LOTTERY';
    
    const historyHTML = trialData.history.map((choice, idx) => {
        const choiceLabel = choice === 1 ? 'IN' : 'OUT';
        const choiceClass = choice === 1 ? 'in' : 'out';
        return `
            <div class="history-box ${choiceClass}">
                <div class="decision-label">${choiceLabel}</div>
            </div>
        `;
    }).join('');
    
    let adviceHTML = '';
    if (trialData.adviceCondition !== 'none') {
        const recClass = trialData.recommendation.toLowerCase();
        adviceHTML = `
            <div class="advice-box ${trialData.advisorColor} hidden" id="advice-display">
                <div class="advice-header ${trialData.advisorColor}">${trialData.advisorId}</div>
                <div class="advice-text">
                    ${trialData.adviceText}
                    <div class="advice-recommendation ${recClass}">${trialData.recommendation}</div>
                </div>
            </div>
        `;
    }
    
    const timerHTML = showTimer ? `
        <div class="timer-bar-container">
            <div class="timer-bar-bg">
                <div class="timer-bar-fill" id="timer-fill"></div>
            </div>
            <div class="timer-warning" id="timer-warning" style="display: none;"></div>
        </div>
    ` : '';
    
    return `
        ${timerHTML}
        
        <div class="history-container" id="history-display">
            <div class="history-title">${partnerLabel} ${trialData.partnerCode}'s history:</div>
            <div class="history-boxes">
                ${historyHTML}
            </div>
        </div>
        
        ${adviceHTML}
        
        <div class="decision-area hidden" id="decision-display">
            <div class="decision-prompt">You have ‚Ç¨${CONFIG.ENDOWMENT}.<br><br>What do you choose?</div>
            <div class="choice-buttons">
                <button class="choice-button in" id="btn-in">IN</button>
                <button class="choice-button out" id="btn-out">OUT</button>
            </div>
        </div>
    `;
}

// ============================================================================
// JSPSYCH EXPERIMENT
// ============================================================================

const jsPsych = initJsPsych({
    on_finish: function() {
        // Get all data
        const allData = jsPsych.data.get();
        
        // Add screen type information to each trial for clarity
        const processedData = allData.values().map(trial => {
            // Identify screen type
            let screenType = 'other';
            if (trial.trial_type === 'html-keyboard-response') {
                if (trial.stimulus && trial.stimulus.includes('Welcome')) screenType = 'welcome';
                else if (trial.stimulus && trial.stimulus.includes('Instructions')) screenType = 'instructions';
                else if (trial.stimulus && trial.stimulus.includes('Comprehension')) screenType = 'comprehension';
                else if (trial.stimulus && trial.stimulus.includes('fixation-cross')) screenType = 'fixation';
                else if (trial.stimulus && trial.stimulus.includes('Break')) screenType = 'break';
                else if (trial.stimulus && trial.stimulus.includes('Advice Section Complete')) screenType = 'advice_complete';
            } else if (trial.trial_type === 'html-button-response') {
                if (trial.stimulus && trial.stimulus.includes('Advice Question')) screenType = 'advice_giving';
                else if (trial.block) screenType = 'decision_trial';
            }
            
            return {
                ...trial,
                screen_type: screenType,
                participant_code: PARTICIPANT_CODE,
                risk_domain: RISK_DOMAIN,
                timestamp: new Date().toISOString()
            };
        });
        
        // Get CSV format
        const csvData = jsPsych.data.get().csv();
        
        // Create comprehensive JSON with all trial details
        const jsonData = JSON.stringify(processedData, null, 2);
        
        // Show completion message with simple instruction format
        document.body.innerHTML = `
            <div class="instructions">
                <h2>Experiment Complete</h2>
                <p>This part of the experiment is over. We will now continue with a few questions.</p>
                <p><em>Press SPACE to continue.</em></p>
            </div>
        `;
        
        // Handle space key press
        document.addEventListener('keydown', function(e) {
            if (e.key === ' ' || e.code === 'Space') {
                // üì§ SEND ALL DATA TO QUALTRICS (if embedded)
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'experiment_complete',
                        participant_code: PARTICIPANT_CODE,
                        risk_domain: RISK_DOMAIN,
                        data_csv: csvData,
                        data_json: jsonData,
                        summary: {
                            total_trials: processedData.filter(t => t.screen_type === 'decision_trial').length,
                            advice_trials: processedData.filter(t => t.screen_type === 'advice_giving').length,
                            completion_time: Date.now()
                        }
                    }, '*');
                } else {
                    // If not in Qualtrics, show message
                    alert('Data saved! (In Qualtrics, this will advance automatically)');
                }
            }
        });
    }
});

jsPsych.data.addProperties({
    participant_code: PARTICIPANT_CODE,
    risk_domain: RISK_DOMAIN,
    date: new Date().toISOString()
});

// ============================================================================
// INSTRUCTIONS
// ============================================================================

const welcome = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
        <div class="instructions">
            <h1>Welcome!</h1>
            <p>Your participant code for this session is: <strong>${PARTICIPANT_CODE}</strong></p>
            <p>You will complete a simple investment task where you make decisions about money.</p>
            <p>Please read the instructions carefully.</p>
            <p><em>Press SPACE to continue.</em></p>
        </div>
    `,
    choices: [' ']
};

const instructions1 = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function() {
        const taskDesc = RISK_DOMAIN === 'Social' ? `
            <p>In each round, you will be paired with another participant.
            You will see their participant code (e.g., KM47, TL23).
            You will interact with a different participant each round.</p>
            <p>You can choose:</p>
            <ul>
                <li><strong>OUT:</strong> You keep your ‚Ç¨10, the other participant gets ‚Ç¨0. The round ends.</li>
                <li><strong>IN:</strong> Your ‚Ç¨10 becomes ‚Ç¨40 and goes to the other participant. Then the other participant decides:
                    <ul>
                        <li><strong>If they choose OUT:</strong> They keep all ‚Ç¨40. You get ‚Ç¨0.</li>
                        <li><strong>If they choose IN:</strong> You split the ‚Ç¨40 equally. You each get ‚Ç¨20.</li>
                    </ul>
                </li>
            </ul>
        ` : `
            <p>In each round, you will be paired with a lottery machine.
            You will see the lottery's ID code (e.g., LM47, LT23).
            You will play a different lottery each round.</p>
            <p>You can choose:</p>
            <ul>
                <li><strong>OUT:</strong> You keep your ‚Ç¨10. The round ends.</li>
                <li><strong>IN:</strong> Your ‚Ç¨10 becomes ‚Ç¨40 and you play the lottery. Then the lottery determines the outcome:
                    <ul>
                        <li><strong>If the lottery result is OUT (you lose):</strong> You get ‚Ç¨0.</li>
                        <li><strong>If the lottery result is IN (you win):</strong> You get ‚Ç¨20.</li>
                    </ul>
                </li>
            </ul>
        `;
        
        return `
            <div class="instructions">
                <h2>Task Instructions</h2>
                ${taskDesc}
                <p><em>Press SPACE to continue.</em></p>
            </div>
        `;
    },
    choices: [' ']
};

const instructions2 = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function() {
        const partnerLabel = RISK_DOMAIN === 'Social' ? "partner's" : "lottery";
        const entity = RISK_DOMAIN === 'Social' ? "participant" : "lottery";
        
        return `
            <div class="instructions">
                <h2>Additional Information</h2>
                <p>You will complete several trials split into 2 blocks.</p>
                <p>You will be paired with a different ${entity} each round.</p>
                <p>Before your decision, you may receive information about the previous behavior of the ${partnerLabel} in rounds with others. You may also receive a recommendation about what to do. Some recommendations will be generated by an AI agent that has been trained on data from previous participants. Other recommendations will be provided by another real participant in this study. You can use this information as you like.</p>
                <p><em>Press SPACE to continue to comprehension check.</em></p>
            </div>
        `;
    },
    choices: [' ']
};

// ============================================================================
// COMPREHENSION CHECK (3 questions - repeats until all correct)
// ============================================================================

const comprehension_q1 = {
    type: jsPsychHtmlButtonResponse,
    stimulus: function() {
        const scenario = RISK_DOMAIN === 'Social' ? 
            'you choose IN and the other participant chooses OUT' :
            'you choose IN and the lottery result is OUT (you lose)';
            
        return `
            <div class="instructions">
                <h2>Comprehension Check - Question 1 of 3</h2>
                <p><strong>Question:</strong> If ${scenario}, how much money do you get?</p>
            </div>
        `;
    },
    choices: ['‚Ç¨0', '‚Ç¨10', '‚Ç¨20', '‚Ç¨40'],
    data: { 
        correct_answer: 0,
        question: 'q1'
    },
    on_finish: function(data) {
        data.correct = data.response === 0;
    }
};

const comprehension_q2 = {
    type: jsPsychHtmlButtonResponse,
    stimulus: function() {
        const scenario = RISK_DOMAIN === 'Social' ? 
            'you choose IN and the other participant chooses IN' :
            'you choose IN and the lottery result is IN (you win)';
            
        return `
            <div class="instructions">
                <h2>Comprehension Check - Question 2 of 3</h2>
                <p><strong>Question:</strong> If ${scenario}, how much money do you get?</p>
            </div>
        `;
    },
    choices: ['‚Ç¨0', '‚Ç¨10', '‚Ç¨20', '‚Ç¨40'],
    data: { 
        correct_answer: 2,
        question: 'q2'
    },
    on_finish: function(data) {
        data.correct = data.response === 2;
    }
};

const comprehension_q3 = {
    type: jsPsychHtmlButtonResponse,
    stimulus: function() {
        return `
            <div class="instructions">
                <h2>Comprehension Check - Question 3 of 3</h2>
                <p><strong>Question:</strong> If you choose OUT, how much money do you get?</p>
            </div>
        `;
    },
    choices: ['‚Ç¨0', '‚Ç¨10', '‚Ç¨20', '‚Ç¨40'],
    data: { 
        correct_answer: 1,
        question: 'q3'
    },
    on_finish: function(data) {
        data.correct = data.response === 1;
    }
};

const comprehension_feedback = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function() {
        const last3 = jsPsych.data.get().last(3).values();
        const allCorrect = last3.every(trial => trial.correct);
        
        if (allCorrect) {
            return `
                <div class="instructions">
                    <div class="comprehension-feedback correct">
                        ‚úì Perfect! You got all questions correct!
                    </div>
                    <p style="margin-top: 30px;"><em>Press SPACE to begin the experiment.</em></p>
                </div>
            `;
        } else {
            const incorrectQs = last3
                .map((trial, idx) => !trial.correct ? (idx + 1) : null)
                .filter(q => q !== null);
            
            return `
                <div class="instructions">
                    <div class="comprehension-feedback incorrect">
                        ‚úó You got question(s) ${incorrectQs.join(', ')} wrong. Let's try again.
                    </div>
                    <p style="margin-top: 20px;"><strong>Remember the key points:</strong></p>
                    <ul style="text-align: left;">
                        <li>If you choose OUT: You keep ‚Ç¨10</li>
                        <li>If you choose IN and ${RISK_DOMAIN === 'Social' ? 'the other participant' : 'the lottery'} chooses OUT: You get ‚Ç¨0</li>
                        <li>If you choose IN and ${RISK_DOMAIN === 'Social' ? 'the other participant' : 'the lottery'} chooses IN: You get ‚Ç¨20</li>
                    </ul>
                    <p><em>Press SPACE to try again.</em></p>
                </div>
            `;
        }
    },
    choices: [' '],
    trial_duration: null
};

const comprehension_loop = {
    timeline: [
        comprehension_q1,
        comprehension_q2,
        comprehension_q3,
        comprehension_feedback
    ],
    loop_function: function() {
        const last3 = jsPsych.data.get().last(4).values().slice(0, 3);
        return !last3.every(trial => trial.correct);
    }
};

// ============================================================================
// GENERATE TRIALS
// ============================================================================

const TRIALS_BLOCK1 = generateTrialSequence(1, PARTNER_CODES_BLOCK1);
const TRIALS_BLOCK2 = generateTrialSequence(2, PARTNER_CODES_BLOCK2);

// Block 1 trials (NO TIMER)
const block1_trials = TRIALS_BLOCK1.map(trialData => ({
    type: jsPsychHtmlButtonResponse,
    stimulus: createTrialHTML(trialData, false),
    choices: ['IN', 'OUT'],
    button_html: '<button style="display:none;">%choice%</button>',
    on_load: function() {
        const btnIn = document.getElementById('btn-in');
        const btnOut = document.getElementById('btn-out');
        const adviceDisplay = document.getElementById('advice-display');
        const decisionDisplay = document.getElementById('decision-display');
        
        // Track when decision buttons become visible (for accurate RT)
        let decisionStartTime = null;
        
        // Sequential display timing
        // 1. History shows immediately
        
        // 2. Show advice after 1.5 seconds
        if (adviceDisplay) {
            setTimeout(() => {
                adviceDisplay.classList.remove('hidden');
                adviceDisplay.classList.add('fade-in');
            }, 1500);
            
            // 3. Show decision buttons after advice appears (1.5s + 1.5s delay)
            setTimeout(() => {
                decisionDisplay.classList.remove('hidden');
                decisionDisplay.classList.add('fade-in');
                decisionStartTime = performance.now(); // Start RT timer
            }, 3000);
        } else {
            // No advice - show decision after 1.5 seconds
            setTimeout(() => {
                decisionDisplay.classList.remove('hidden');
                decisionDisplay.classList.add('fade-in');
                decisionStartTime = performance.now(); // Start RT timer
            }, 1500);
        }
        
        // Handle button clicks with RT tracking
        btnIn.onclick = () => {
            const rt = decisionStartTime ? performance.now() - decisionStartTime : null;
            jsPsych.finishTrial({choice: 'IN', rt_from_buttons_visible: rt});
        };
        btnOut.onclick = () => {
            const rt = decisionStartTime ? performance.now() - decisionStartTime : null;
            jsPsych.finishTrial({choice: 'OUT', rt_from_buttons_visible: rt});
        };
    },
    on_finish: function(data) {
        const choice = data.choice;
        let participantPayoff, partnerPayoff;
        
        if (choice === 'OUT') {
            participantPayoff = CONFIG.ENDOWMENT;
            partnerPayoff = CONFIG.ENDOWMENT;
        } else {
            if (trialData.willCooperate) {
                participantPayoff = CONFIG.SHARE_AMOUNT;
                partnerPayoff = CONFIG.SHARE_AMOUNT;
            } else {
                participantPayoff = 0;
                partnerPayoff = 40;
            }
        }
        
        const hasAdvice = trialData.adviceCondition !== 'none';
        const followedGoodAdvice = hasAdvice && trialData.quality === 'good' && 
                                   choice === trialData.recommendation;
        const followedAdvice = hasAdvice && choice === trialData.recommendation;
        
        data.block = trialData.block;
        data.trial_num = trialData.trialNum;
        data.partner_code = trialData.partnerCode;
        data.advice_condition = trialData.adviceCondition;
        data.advisor_id = trialData.advisorId || 'NA';
        data.advice_quality = trialData.quality;
        data.advice_recommendation = trialData.recommendation || 'NA';
        data.history = JSON.stringify(trialData.history);
        data.cooperation_rate = trialData.cooperationRate;
        data.optimal_choice = trialData.optimalChoice;
        data.history_label = trialData.historyLabel;
        data.chose_optimal = choice === trialData.optimalChoice;
        data.will_cooperate = trialData.willCooperate;
        data.participant_payoff = participantPayoff;
        data.partner_payoff = partnerPayoff;
        data.cognitive_load = 'Low';
        data.has_advice = hasAdvice;
        data.followed_advice = followedAdvice;
        data.followed_good_advice = followedGoodAdvice;
        
        // RT tracking: we have both jsPsych's default RT (from trial start) 
        // and our custom RT (from when buttons became visible)
        data.rt_jspsych = data.rt; // jsPsych's built-in RT from trial start
        data.rt_decision = data.rt_from_buttons_visible || data.rt; // RT from buttons visible
    },
    post_trial_gap: CONFIG.ITI_DURATION
}));

// Break screen
const break_screen = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
        <div class="instructions">
            <h2>Block 1 Completed</h2>
            <p>Please wait while we continue to Block 2.</p>
            
            <div class="stress-warning">
                ATTENTION<br>
                In the next block, you will have<br>
                <strong>limited time</strong><br>
                to make each choice!<br>
                You must be quick!
            </div>
            
            <div class="break-countdown" id="countdown">${CONFIG.BREAK_DURATION/1000}</div>
            <p>The next block will begin automatically...</p>
        </div>
    `,
    choices: "NO_KEYS",
    trial_duration: CONFIG.BREAK_DURATION,
    on_load: function() {
        let timeLeft = CONFIG.BREAK_DURATION / 1000;
        const countdownElement = document.getElementById('countdown');
        const interval = setInterval(() => {
            timeLeft--;
            if (countdownElement && timeLeft >= 0) {
                countdownElement.textContent = timeLeft;
            }
            if (timeLeft < 0) {
                clearInterval(interval);
            }
        }, 1000);
    }
};

// Block 2 trials (WITH TIMER)
const block2_trials = TRIALS_BLOCK2.map(trialData => ({
    type: jsPsychHtmlButtonResponse,
    stimulus: createTrialHTML(trialData, true),
    choices: ['IN', 'OUT'],
    button_html: '<button style="display:none;">%choice%</button>',
    trial_duration: CONFIG.DECISION_TIME_WITH_PRESSURE + 3000, // Add time for sequential display
    on_load: function() {
        const btnIn = document.getElementById('btn-in');
        const btnOut = document.getElementById('btn-out');
        const fill = document.getElementById('timer-fill');
        const warning = document.getElementById('timer-warning');
        const adviceDisplay = document.getElementById('advice-display');
        const decisionDisplay = document.getElementById('decision-display');
        
        let responded = false;
        let isRunning = false; // Timer starts later
        let lastPercent = 100;
        let startTime;
        let decisionStartTime; // Track when buttons become visible for RT
        
        if (!fill || !warning || !btnIn || !btnOut) {
            console.error('Required elements not found');
            return;
        }
        
        fill.style.width = '100%';
        fill.style.background = 'linear-gradient(90deg, #ef4444 0%, #dc2626 100%)';
        warning.style.display = 'none';
        warning.textContent = '';
        
        // Sequential display timing
        // 1. History shows immediately
        
        // 2. Show advice after 1.5 seconds
        const adviceDelay = adviceDisplay ? 1500 : 0;
        if (adviceDisplay) {
            setTimeout(() => {
                adviceDisplay.classList.remove('hidden');
                adviceDisplay.classList.add('fade-in');
            }, 1500);
        }
        
        // 3. Show decision buttons and START TIMER after advice (1.5s after advice)
        setTimeout(() => {
            decisionDisplay.classList.remove('hidden');
            decisionDisplay.classList.add('fade-in');
            
            // Start timer and RT tracking
            isRunning = true;
            startTime = Date.now();
            decisionStartTime = performance.now(); // Start RT timer
            requestAnimationFrame(updateTimer);
        }, adviceDelay + 1500);
        
        function updateTimer() {
            if (!isRunning || responded) {
                return;
            }
            
            const elapsed = Date.now() - startTime;
            const remaining = CONFIG.DECISION_TIME_WITH_PRESSURE - elapsed;
            
            if (remaining <= 0) {
                isRunning = false;
                if (fill) fill.style.width = '0%';
                return;
            }
            
            const percent = Math.max(0, Math.min(100, (remaining / CONFIG.DECISION_TIME_WITH_PRESSURE) * 100));
            const seconds = Math.ceil(remaining / 1000);
            
            if (Math.abs(percent - lastPercent) >= 0.5) {
                lastPercent = percent;
                fill.style.width = percent + '%';
                
                if (percent < 30) {
                    fill.style.background = 'linear-gradient(90deg, #7f1d1d 0%, #991b1b 100%)';
                }
            }
            
            if (seconds <= 5) {
                if (warning.style.display === 'none') {
                    warning.textContent = 'HURRY!';
                    warning.style.display = 'block';
                }
            } else {
                if (warning.style.display !== 'none') {
                    warning.style.display = 'none';
                }
            }
            
            if (isRunning && !responded) {
                requestAnimationFrame(updateTimer);
            }
        }
        
        function handleResponse(choice) {
            if (!responded) {
                responded = true;
                isRunning = false;
                const rt = decisionStartTime ? performance.now() - decisionStartTime : null;
                jsPsych.finishTrial({choice: choice, timeout: false, rt_from_buttons_visible: rt});
            }
        }
        
        btnIn.onclick = () => handleResponse('IN');
        btnOut.onclick = () => handleResponse('OUT');
    },
    on_finish: function(data) {
        const choice = data.response === null ? 'timeout' : data.choice;
        let participantPayoff, partnerPayoff;
        
        if (choice === 'timeout' || choice === 'OUT') {
            participantPayoff = choice === 'timeout' ? 0 : CONFIG.ENDOWMENT;
            partnerPayoff = CONFIG.ENDOWMENT;
        } else {
            if (trialData.willCooperate) {
                participantPayoff = CONFIG.SHARE_AMOUNT;
                partnerPayoff = CONFIG.SHARE_AMOUNT;
            } else {
                participantPayoff = 0;
                partnerPayoff = 40;
            }
        }
        
        const hasAdvice = trialData.adviceCondition !== 'none';
        const followedGoodAdvice = hasAdvice && trialData.quality === 'good' && 
                                   choice === trialData.recommendation;
        const followedAdvice = hasAdvice && choice === trialData.recommendation;
        
        data.block = trialData.block;
        data.trial_num = trialData.trialNum;
        data.partner_code = trialData.partnerCode;
        data.advice_condition = trialData.adviceCondition;
        data.advisor_id = trialData.advisorId || 'NA';
        data.advisor_color = trialData.advisorColor || 'NA';
        data.advice_quality = trialData.quality;
        data.advice_recommendation = trialData.recommendation || 'NA';
        data.history = JSON.stringify(trialData.history);
        data.cooperation_rate = trialData.cooperationRate;
        data.optimal_choice = trialData.optimalChoice;
        data.history_label = trialData.historyLabel;
        data.chose_optimal = choice === trialData.optimalChoice;
        data.will_cooperate = trialData.willCooperate;
        data.participant_payoff = participantPayoff;
        data.partner_payoff = partnerPayoff;
        data.choice = choice;
        data.cognitive_load = 'High';
        data.has_advice = hasAdvice;
        data.followed_advice = followedAdvice;
        data.followed_good_advice = followedGoodAdvice;
        
        // RT tracking: we have both jsPsych's default RT (from trial start) 
        // and our custom RT (from when buttons became visible)
        data.rt_jspsych = data.rt; // jsPsych's built-in RT from trial start
        data.rt_decision = data.rt_from_buttons_visible || data.rt; // RT from buttons visible
        data.timed_out = choice === 'timeout'; // Flag if participant timed out
    },
    post_trial_gap: CONFIG.ITI_DURATION
}));

// ============================================================================
// ADVICE GIVING TRIALS (3 trials at the end)
// ============================================================================

// All 8 possible history combinations
const ALL_HISTORY_COMBOS = [
    [0, 0, 0], // All OUT
    [0, 0, 1], // OUT, OUT, IN
    [0, 1, 0], // OUT, IN, OUT
    [0, 1, 1], // OUT, IN, IN
    [1, 0, 0], // IN, OUT, OUT
    [1, 0, 1], // IN, OUT, IN
    [1, 1, 0], // IN, IN, OUT
    [1, 1, 1]  // All IN
];

// Assign participant to a set based on their participant code
// This ensures each combination appears equally across all participants
function getParticipantHistorySet(participantCode) {
    // Use participant code to deterministically select 3 of 8 combinations
    // Convert code to number for consistent assignment
    let codeNum = 0;
    for (let i = 0; i < participantCode.length; i++) {
        codeNum += participantCode.charCodeAt(i);
    }
    
    // Use modulo 8 to assign to one of 8 groups
    // Each group gets 3 different history combinations
    const groupNum = codeNum % 8;
    
    const historySets = [
        [0, 1, 2], // Group 0: [000], [001], [010]
        [1, 2, 3], // Group 1: [001], [010], [011]
        [2, 3, 4], // Group 2: [010], [011], [100]
        [3, 4, 5], // Group 3: [011], [100], [101]
        [4, 5, 6], // Group 4: [100], [101], [110]
        [5, 6, 7], // Group 5: [101], [110], [111]
        [6, 7, 0], // Group 6: [110], [111], [000]
        [7, 0, 1]  // Group 7: [111], [000], [001]
    ];
    
    return historySets[groupNum].map(idx => ALL_HISTORY_COMBOS[idx]);
}

// Generate 3 advice scenarios with systematic history assignment
const participantHistories = getParticipantHistorySet(PARTICIPANT_CODE);
const ADVICE_SCENARIOS = participantHistories.map((history, idx) => {
    const partnerCode = generateParticipantCode();
    return { partnerCode, history };
});

const advice_giving_trials = ADVICE_SCENARIOS.map((scenario, idx) => ({
    type: jsPsychHtmlButtonResponse,
    stimulus: function() {
        const partnerLabel = RISK_DOMAIN === 'Social' ? 'PARTICIPANT' : 'LOTTERY';
        
        const historyHTML = scenario.history.map((choice) => {
            const choiceLabel = choice === 1 ? 'IN' : 'OUT';
            const choiceClass = choice === 1 ? 'in' : 'out';
            return `
                <div class="history-box ${choiceClass}">
                    <div class="decision-label">${choiceLabel}</div>
                </div>
            `;
        }).join('');
        
        return `
            <div style="max-width: 900px; margin: 80px auto; padding: 30px;">
                <div style="background: #f7fafc; padding: 30px; border-radius: 10px; margin-bottom: 30px;">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <strong style="font-size: 18px;">${partnerLabel} ${scenario.partnerCode}'s history:</strong>
                    </div>
                    <div class="history-boxes" style="display: flex; justify-content: center; gap: 15px;">
                        ${historyHTML}
                    </div>
                </div>
                
                <p style="font-size: 20px; text-align: center; margin: 30px 0 20px 0;">
                    Another participant is about to make a decision. What would you advise given this history on 3 previous rounds?
                </p>
            </div>
        `;
    },
    choices: ['Advise IN', 'Advise OUT'],
    button_html: `
        <button style="width: 250px; height: 80px; font-size: 24px; font-weight: bold; 
                       border: 4px solid black; border-radius: 8px; cursor: pointer; 
                       margin: 0 20px; transition: all 0.2s;
                       background-color: %choice% === 'Advise IN' ? '#e8f4ff' : '#fff0e8';">
            %choice%
        </button>
    `,
    on_finish: function(data) {
        data.trial_type = 'advice_giving';
        data.advice_trial_num = idx + 1;
        data.partner_code = scenario.partnerCode;
        data.history = JSON.stringify(scenario.history);
        data.advice_given = data.response === 0 ? 'IN' : 'OUT';
    }
}));

// Final transition message after advice trials
const advice_complete = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
        <div class="instructions">
            <p>We will now continue with the investment task.</p>
            <p><em>Press SPACE to continue.</em></p>
        </div>
    `,
    choices: [' ']
};

// ============================================================================
// FULL TIMELINE
// ============================================================================

const timeline = [
    welcome,
    instructions1,
    instructions2,
    comprehension_loop
];

// Separate Block 1 trials by advice type
const block1_no_advice = block1_trials.filter((_, idx) => TRIALS_BLOCK1[idx].adviceCondition === 'none');
const block1_with_advice = block1_trials.filter((_, idx) => TRIALS_BLOCK1[idx].adviceCondition !== 'none');

// Add Block 1 NO ADVICE trials with fixation crosses
block1_no_advice.forEach(trial => {
    timeline.push(createFixation());
    timeline.push(trial);
});

// Add advice giving trials (RIGHT AFTER no-advice trials)
advice_giving_trials.forEach(trial => {
    timeline.push(trial);
});
timeline.push(advice_complete);

// Add Block 1 WITH ADVICE trials (AI and human) with fixation crosses
block1_with_advice.forEach(trial => {
    timeline.push(createFixation());
    timeline.push(trial);
});

// Add break
timeline.push(break_screen);

// Add Block 2 trials with fixation crosses
block2_trials.forEach(trial => {
    timeline.push(createFixation());
    timeline.push(trial);
});

jsPsych.run(timeline);

</script>
</html>
